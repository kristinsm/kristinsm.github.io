---
layout:     post
title:      javascrpit
subtitle:   基础语法
date:       2022-07-23
author:     BY
header-img: img/post-bg-ios9-web.jpg
catalog: 	 true
tags:
    - javascript
---


###    && || 非布尔值的情况
        - 对于非布尔值进行与或运算时
            先将其转换为布尔值，然后再运算，并返回原值 例如：
                                                            3 && 4 结果为3
        与运算：
        - 如果第一个值为true，则必然返回第二个值
        - 如果第一个值为false,则直接返回第一个值
        或运算：
        -如果第一个值为true，则直接返回第一个
        -如果第一个值为false，则直接返回第二个
            -- 示例： "" || "hello" 返回 "false"(注意：""的值为false "asd"为true)

## 关系运算符 > < >= <=
* 特殊情况：如果两侧都是数字 "123" <"12" 不会将其转换为数字进行比较，而会分别比较Unicode编码
    + 如果一侧为非数值,一侧为数值，会将其转换为数字，然后再比较
    - 非数值分为两种情况：
        + 1.字符串型数字 "123 转换为123
        + 2.非字符串型数字 "saldkjas" 转换为NaN,该情况下返回值永远为false

## 条件运算符（三元运算符）
+ 语法：条件表达式?语句1:语句2
+ 如果条件表达式值为true，则试行语句1，否则执行语句2

js中可以使用{}来为语句进行分组,同一个分组中的语句要么都执行，要么都不执行


#### 创建一个函数对象
    var fun = new Function(); //这种形式使用较少
    一般使用如下形式：
    Function fun(){
        
    }

### 立即执行函数
```
    #函数定义完，立即被调用
    (function(){
        alert();
    })(这里可以传参);
``` 


## 枚举
* 语法：
    ```
        for(var 变量 in 对象){
        }
    ```
+ 在for...in语句对象中，有几个属性，循环体就会执行几次
    - 每次执行时，会将对象中的一个属性名赋值给变量

## 作用域
* #### 全局变量
  * 全局作用域在页面打开时创建，在页面关闭时销毁
  * 在全局作用域中有一个全局对象window
    + 它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用
  * 在全局作用域中：创建的变量豆浆作为windows对象的属性保存
    * 示例：
        ```
            //输出结果为 10
            var a = 10
            console.log(window.a);
        ```
  * 变量的声明提前
    * 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值）
        + 但是如果生面变量不使用var关键字，则变量不会被提前声明
  * 函数的声明提前
    * 使用function关键字声明的函数，会在所有代码执行之前被创建，可以在函数被声明之前调用
    * 使用表达式声明的函数不会被提前创建
* #### 函数作用域
  * 调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁

## 隐含参数this(调用谁,谁就是this)
* 解析器在调用函数时每次都会向函数内部传递进一个隐含的参数 this
  * 根据函数的调用方式的不同，this会指向不同的对象
    * 以函数形式调用时，this永远都是window
    * 以方法的形式调用时，this就是调用方法的那个对象
    ```
        function fun(){
            console.log(this.name)
        }
        //创建一个对象
        var obj = {
            name:"a"
            sayname:fun
        }
        obj.sayname();//此时就是以方法的形式调用，this = obj
        fun();//此时是以函数的形式调用,this = window
    ```     
### 工厂方法创建对象
+ 示例
```
    function create(){
        var obj = new Object(name, age);
          obj.name = name;
          obj,age = age;
          obj.sayname = function(){
              alert(this.name)
          }
        return obj;
    }
    var obj2 = creat("a", 18);
```

## 构造函数
+ 构造函数就是一个普通的函数，创建方式和普通函数没有区别
    + 不同的是 构造函数习惯上首字母大写
+ 构造函数和普通函数的区别就是调用方式的不同
    - 普通函数是直接调用，而构造函数需要使用 new 关键字来调用（简单来说就是给Object函数换个名字）
+ 构造函数的执行流程：
    + 立即创建一个新的对象
    + ## 将新建的对象设置为函数中的 this（这个this 就是我们新建的对象）
        + 在构造函数中可以使用this来引用新创建的对象
    + 逐行执行函数中的代码
    + 将新建的对象作为返回值返回
+ 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类
    + 我们通过一个构造函数创建的对象，称为是该类的示例
    + 以后我们创建构造函数时，可以将这些共有的属性和方法，统一添加到构造函数的原型对象中
        + 这样既不用给每个对象添加，也不会影响全局作用域，就可以让实例都具有这些属性和方法

## this
+ 当以函数的形式调用时，this就是windows
+ 当以方法的形式调用时，谁调用方法，this就是谁
+ 当以构造函数形式调用时，this就是新创建的那个对象


## 原型(prototype)：原型是固定的
+ ## 原型中的函数可以被对象中的函数覆盖
+ ## 原型对象也是对象，所以它也有原型
    + Object对象没有原型
    + 原型的原型：以对象mc为例：
        + mc.__proto__.__proto__(看md源代码)
+ 我们创建的每一个函数，解析器都会向函数中添加一个属性prototype
    + 这个属性对应着一个对象，这个对象就是原型对象
+ 当函数作为普通函数调用prototype没有任何作用
+ 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含属性指定该构造函数的原型对象
    + 我们可以通过 __proto__来访问该属性
+ ## 原型对象就相当于一个公共的区域
    + 所有同一个类的实例都可以访问到这个原型对象
    + 我们可以将对象中共有的内容，统一设置到原型对象中,添加之后所有的实例中都有这个属性/方法
        + 注意：当实例中原本就拥有这个属性时，会直接使用这个属性而不会调用原型对象中的属性/方法
            + 如果没有，则会去原型对象中寻找（如果原型对象中也没有，那么会去原型对象的原型中去找，直至找到Object，如果还是没找到则返回Undefined），如果找到则使用
```
    \\向构造函数MyClass函数中添加属性a
    MyClass.prototype.a = 123;
```
## hasOwnProperty()函数:该函数存在于原型的原型中
+ 该函数可以检查对象自身中是否含有某个属性
```
    var mc = new Object();
    mc.hasOwnProperty("属性名")//检查mc本身，不管它的原型对象中是否含有该属性
```
### 数组（Array）
```
    var arr = new Array();
```
+ #### 向数组中添加元素
    + 语法：数组[索引] = 值
    + 如果读取不存在的索引，会返回Undefined
```
    arr[0] = 10;
```
+ 遍历数组的方式
    + 1.for循环(与C语言相同)
    + 2.forEach()
        + 该方式需要一个函数作为参数
            + 该函数由我们创建但是不由我们调用，称为回调函数
            + 数组中有几个元素，函数就会执行几次
                + 每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参，来读取这些内容
            + 浏览器会在回调函数中传递三个参数
                + 第一个参数： 当前正在遍历的元素
                + 第二个参数： 当前正在遍历的元素的索引
                + 第三个参数： 当前遍历的Array（数组）
        + 这个方法只支持ie8以上的浏览器
    ```
        arr.forEach(function(){
            
        })
    ```
+ ## slice(start,end)
    + 将截取到的元素封装到一个新数组中返回,不影响原数组
```
    var result = arr.slice(0,2); 
```
+ ## splice(start,end,new1，new2)
    + 用于删除数组中的指定元素
    + 使用splice()会影响到原数组
        + 并将被删除的元素作为返回值返回
        + 第一个参数是开始位置
        + 第二个参数是删除的个数
        + 第三个参数及以后：这些参数会自动插入到索引开始位置前边
## 函数对象的方法: call() apply()
+ 这两个方法都是函数对象的方法，需要通过函数对象来调用
```
    function fun(){
        ...
    }
    fun.call();
```
+ 当对函数调用call()和apply()都会调用函数执行
+ 调用call()和apply()可以将一个对象指定为第一个参数
    + 此时这个对象会成为函数执行时的this
    + call()方法可以将实参在对象之后依次传递
    + apply()方法需要将实参封装到一个数组中统一传递
```
    function fun(a,b){
        console.log("a = "+a);
        console.log("b = "+b); 
    };
    var obj = {};
    fun.call(obj,2,3);
    fun.apply(obj,[2,3]);
```

## arguments
+ 一个类数组对象
+ 在调用函数时，我们所传递的实参都会在arguments中保存


## date对象
+ 创建date对象
    + 如果直接使用构造函数创建一个date对象，会封装当前代码执行的时间
```
    var date = new Date();
```
+ 创建指定的实践对象
```
    var date2 = new Date("12/03/2016 11:10:30")
```
***
## 事件
+ 定义：用户与浏览器之间的交互行为，例如：点击按钮，鼠标移动，关闭窗口……
+ 我们可以在时间的属性中设置一些js代码，当事件被触发时，这些代码会被执行
    + 具体例子 看 事件.html
+ 在事件的响应函数中，事件是给谁绑定的,this就是谁，案例见 全选练习.html

*****

## 通过JS修改元素的样式
+ 语法： 元素.style.样式名 = 样式值
    + 通过style读取的都是内联样式
    + 注意：如果css样式中含有-(background-color)，这种名称在JS中是不合法的
        +  需要将这种样式名修改为驼峰命名法，即 去掉-，然后将-后的字母大写
        + 如果在样式中写了 !important，则样式会有最高的优先级
            + 因此，尽量不要给样式写入!important
+ 使用getComputedStyle()方法获取元素当前的样式
    + 这个方法是window的方法，可以直接使用
    + 需要两个参数：
        + 第一个，要获取样式的元素
        + 第二个，可以穿第一个伪元素，一般都传null
    + 该方法会返回一个对象，对象中封装了当前元素对应的样式
+ 通过currentStyle和getComputedStyle()读取到的样式都不能修改